% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fast_big_lm.R
\name{bigLm}
\alias{bigLm}
\alias{bigLm.default}
\title{fast and memory efficient linear model fitting}
\usage{
bigLm(X, ...)

\method{bigLm}{default}(X, y, method = 0L, gigs = 2, nslices = NULL, ...)
}
\arguments{
\item{X}{input model matrix. must be a big.matrix object (type = 8 for double)}

\item{...}{not used}

\item{y}{numeric response vector of length nobs.}

\item{method}{an integer scalar with value 0 for the LLT Cholesky or 1 for the LDLT Cholesky}

\item{gigs}{double scalar. maximum number of gigs of memory available. Used to figure out how to break up calculations
involving the design matrix X}

\item{nslices}{integer scalar, defaults to NULL, which defers to the \code{gigs} argument to determine the number of slices
required. If specified, nslices determines the number of slices to break up computation of X'X into.}
}
\value{
A list object with S3 class "bigLm" with the elements
\item{coefficients}{a vector of coefficients}
\item{se}{a vector of the standard errors of the coefficient estimates}
\item{rank}{a scalar denoting the computed rank of the model matrix}
\item{df.residual}{a scalar denoting the degrees of freedom in the model}
\item{residuals}{the vector of residuals}
\item{s}{a numeric scalar - the root mean square for residuals}
\item{fitted.values}{the vector of fitted values}
}
\description{
fast and memory efficient linear model fitting

bigLm default
}
\examples{

library(bigmemory)

nrows <- 50000
ncols <- 50
bkFile <- "bigmat.bk"
descFile <- "bigmatk.desc"
bigmat <- filebacked.big.matrix(nrow=nrows, ncol=ncols, type="double",
                                backingfile=bkFile, backingpath=".",
                                descriptorfile=descFile,
                                dimnames=c(NULL,NULL))

# Each column value with be the column number multiplied by
# samples from a standard normal distribution.
set.seed(123)
for (i in 1:ncols) bigmat[,i] = rnorm(nrows)*i

y <- rnorm(nrows) + bigmat[,1]

system.time(lmr1 <- bigLm(bigmat, y))

system.time(lmr2 <- lm.fit(x = bigmat[,], y = y))

max(abs(coef(lmr1) - coef(lmr2)))


}

